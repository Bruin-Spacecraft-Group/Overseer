# -*- coding: utf-8 -*-
"""cutdown_method.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zoKJ5_D4zuB8nFyH3ENSaBz3V0ML60PD
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
from collections import defaultdict
from shapely.geometry import Point, Polygon


# Import our “predicted coordinates” and current HAB altitude
# 	Set x coordinate = xcord
# 	Set Y coordinate = ycord
# 	Set altitude = Altitude
# 	Define max altitude = MaxAltitude
# 	Define int = hi = 0

# Import series of all GPS coordinates, x length, and y length	(n of these)	#super easy to do!
# OR … Import our direct map KML file				#this has several benefits but will be much more challenging

# If (Altitude < MaxAltitude)
# 	Get stuck in this loop, do nothing				#since we don’t want to cutdown at a low altitude

# For ( all different shapes “n” / coordinates)
# 	RedZone = shapely shape from (GPS coordinates, x length, and y length);
# 	If ( xcord, ycord is within RedZone)
# 		Hi = 1
# If (Hi == 1)
# 	Initiate cutdown sequence



#Onboard - define where the balloon is predicted to land at a certain instance
class Prediction:
    def __init__(self, startx, starty):
        self.predx_land = startx
        self.predy_land = starty
        self.max_alt = 20
        self.alt = 0
    def pred_x(self):
        self.predx_land -= 0.01
        print(self.predx_land)
        return self.predx_land
    def pred_y(self):
        print(self.predy_land)
        return self.predy_land
    def altitude(self):
        self.alt += 1
        return self.alt
    def cutdown(self):
        print("DONE")
        return

#Import GeoFence Coords
region_0 = pd.read_csv("/content/drive/Shareddrives/Bruin Space/Projects/Overseer/2020-2021/Spring/Software/NewCoords/Square 0.csv")["Polygon/outerBoundaryIs/LinearRing/coordinates"]
region_1 = pd.read_csv("/content/drive/Shareddrives/Bruin Space/Projects/Overseer/2020-2021/Spring/Software/NewCoords/Square 1.csv")["Polygon/outerBoundaryIs/LinearRing/coordinates"]
region_3 = pd.read_csv("/content/drive/Shareddrives/Bruin Space/Projects/Overseer/2020-2021/Spring/Software/NewCoords/Square 3.csv")["Polygon/outerBoundaryIs/LinearRing/coordinates"]
region_4 = pd.read_csv("/content/drive/Shareddrives/Bruin Space/Projects/Overseer/2020-2021/Spring/Software/NewCoords/Square 4.csv")["Polygon/outerBoundaryIs/LinearRing/coordinates"]
region_5 = pd.read_csv("/content/drive/Shareddrives/Bruin Space/Projects/Overseer/2020-2021/Spring/Software/NewCoords/Square 5.csv")["Polygon/outerBoundaryIs/LinearRing/coordinates"]
region_8 = pd.read_csv("/content/drive/Shareddrives/Bruin Space/Projects/Overseer/2020-2021/Spring/Software/NewCoords/Square 8.csv")["Polygon/outerBoundaryIs/LinearRing/coordinates"]
region_9 = pd.read_csv("/content/drive/Shareddrives/Bruin Space/Projects/Overseer/2020-2021/Spring/Software/NewCoords/Square 9.csv")["Polygon/outerBoundaryIs/LinearRing/coordinates"]
all_regions = [region_0, region_1, region_3, region_4, region_5, region_8, region_9]

#Just for reference
# #Point(x, y)
# #['-117.3961004,35.7783814,0', '-117.3974777,35.6501786,0', 
# #'-117.2642917,35.6490576,0', '-117.2684077,35.7794931,0', '-117.3961004,35.7783814,0']

# #TEST WITHIN: 35.72621, -117.33631
# #TEST OUTSIDE: 35.73123, -117.43313

# '-117.3961004,35.7783814,0' --> list = [-117.3961004, 35.7783814, 0] --> y, x, 0
# Point(x, y) --> Point(list[1], list[0])

# shape = [Point(x, y), Point(x, y), Point(x, y), Point(x, y), Point(x, y)]
# curr_poly = Polygon(shape)

# mapped_regions --> {0: Polygon(details about the polygon), 1: Polygon(), 2: -->}

#PARSING COORDINATES FROM CSV

mapped_regions = defaultdict(list)
#{key: values, key: values}
count = 0
for region in all_regions: #region_0
    for coord_set in region: #Iterate through every shape in the region
        split_coords = coord_set.split()
        shape = []
        for s in split_coords:
            lat_long_0 = s.split(",") # abc,def,g --> [abc, def, g]
            shape.append(Point(float(lat_long_0[1]), float(lat_long_0[0])))
        curr_poly = Polygon(shape)
        mapped_regions[count] = curr_poly
        count += 1

# #TESTING THE PARSER

# curr_loc = Point(predx_land, predy_land)

# found_within = 0
# for shape in mapped_regions:
#     if curr_loc.within(mapped_regions[shape]):
#         found_within = 1
# if found_within == 0:
#     print("OUTSIDE")

#The "IDEA" of how balloon cutdown should run
def run_tests(x, y):
    pred = Prediction(x, y)

    def check_within_red(curr_loc):
        for shape in mapped_regions:
            if curr_loc.within(mapped_regions[shape]):
                return True

    def update_loc(c):
        return Point(pred.pred_x(), pred.pred_y())

    stop = 0
    while True:
        while pred.altitude() < pred.max_alt:
            print("nice")
            continue
        while check_within_red(update_loc(pred)):
            continue 
        while True:
            if check_within_red(update_loc(pred)):
                pred.cutdown()
                stop = 1
                break
        if stop:
            break
run_tests(35.3084, -118.57268)

#Case 1: In red zone & at max alt --> KEEP going until the balloon exits its current red zone --> cut down when it enters another red zone
#Case 2: In white zone & at max alt --> cut down when it enters a red zone

##### TEST SECTION